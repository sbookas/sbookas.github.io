<HTML>

<HEAD>
<meta charset = "UTF-8"> 
<TITLE>Дополнение к главе 2</TITLE>
<link rel = "stylesheet" href ="https://sbookas.github.io/main.css">
</HEAD>


<BODY>



<h1><B>Дополнение к главе II</B></h1>


<h3 ><A HREF="#2.1.HTML">2.1 Программирование перевода чисел из одной системы счисления в другую</A></h2> 




<h3><A HREF="#2.2">2.2 Сложность алгоритмов</A></h2>





<h3><A HREF="#2.3">2.3 О языках программирования и трансляторах</A></h2>







	<A NAME="2.1.HTML"></a>

<h3 align ="center">
	<b><a>2.1 Программирование перевода чисел из одной системы счисления в другую</b></a>
</h3>

<P ALIGN="left">
<a><I><b>Основные темы параграфа:</b></I></a>

<p>&nbsp;&nbsp;<I>*Перевод двоичного числа в десятичную систему счисления;</I>

<p>&nbsp;&nbsp;<I>*Перевод десятичного числа в двоичную систему счисления.</I>

<p>&nbsp;&nbsp;&nbsp;В $ 18 учебника для 8 класса рассказано о двоичной системе счисления, 
которая используется в компьютере для представления чисел и выполнения вычислений с ними. 
Там же описаны правила, по которым можно вручную выполнить перевод двоичных чисел в десятичную 
систему счисления и обратный перевод — десятичных чисел
в двоичные. Рассмотрим программы на Паскале для автоматического перевода чисел из одной системы 
счисления в другую. Ограничимся переводом целых чисел.


<p>&nbsp;&nbsp;&nbsp;<b><a>Программа перевода двоичного числа в десятичную систему
	счисления</a></b>

<p>&nbsp;&nbsp;&nbsp;Рассмотрим программу на Паскале, по которой происходит пере-
вод целого двоичного числа в десятичную систему.

<IMG SRC="image/1.png" HEIGHT="500"><br>

<p>&nbsp;&nbsp;&nbsp;В программе использованы следующие переменные:
<p>&nbsp;&nbsp;&nbsp;№2 — целое двоичное число — исходное данное;
<p>&nbsp;&nbsp;&nbsp;№10 — десятичное число — результат;

<p>&nbsp;&nbsp;&nbsp;Тип <i>longint</i> — длинный целый тип. Значения величин этого типа
лежат в диапазоне от —2 147 483 648 до 2 147 483 647. Значит, данная программа может работать с числами, не более чем 9-значными.

<p>&nbsp;&nbsp;&nbsp;В этой программе используются две незнакомые вам операции
с целыми числами. Операция <b>div</b> — целочисленное деление. Дели-
мое и делитель являются целыми числами, а результат — целая
часть частного. Например: 7 <b>div</b> 2 = 3. Для отбрасывания младше-
го разряда целого числа используется целочисленное деление на 10.Например: 1234 
<b>div</b> 10 = 123 — отбрасывается младший разряд.

<p>&nbsp;&nbsp;&nbsp;Операция <b>mod</b> дает остаток от целочисленного деления. Напри-
мер: 7 <b>mod</b> 2 = 1. Для получения младшего разряда целого числа
вычисляется остаток от целочисленного деления на 10. Например:
1234 <b>mod</b> 10 = 4 — выделяется разряд единиц.


<p>&nbsp;&nbsp;&nbsp;<b><u>Пример</u></b>. При переводе по данной программе двоичного числа
1101, в десятичную систему на экране увидим:

<p>&nbsp;&nbsp;&nbsp;№2=1101

<p>&nbsp;&nbsp;&nbsp;№0=13

<p>&nbsp;&nbsp;&nbsp;Следовательно, в итоге получили: 1 101,=13.

<p>&nbsp;&nbsp;&nbsp;Для лучшего понимания работы программы внимательно изучи-
те приведенную далее трассировочную таблицу. Она отражает изме
нения значений переменных на каждом шаге выполнения алгоритма, реализованного в программе.

<P ALIGN="CENTER">
<IMG SRC="image/2.png" HEIGHT="1000" ALIGN="center"><br>
</P>
<p><b><a>Программа перевода десятичного числа в двоичную систему
	счисления</a></b>

<p>Теперь познакомьтесь с программой перевода целого десятичного
числа в двоичную систему счисления. 

<P ALIGN="left">
<IMG SRC="image/3.png" HEIGHT="500" ALIGN="center"><br>
</P><br>
<p>Здесь использованы те же обозначения, что и в предыдущей программе. Исходными данными являются: N10 — десятичное число.
Результат получается в переменной N2 — число в системе с основанием 2.

<p>В алгоритме используется циклс постусловием <b>(гереаt ... untill).</b>
Цикл повторяется до выполнения условия: N10 = 0.

<p>&nbsp;&nbsp;&nbsp;<b><i>Пример</i></b> использования программы. Переведем число 25 в двоичную систему счисления. Работа программы на экране компьютера
отразится следующим образом:

<p>&nbsp;&nbsp;&nbsp;N10=25

<p>&nbsp;&nbsp;&nbsp;N2=11001

<p>&nbsp;&nbsp;&nbsp;Следовательно, в результате получили: 25 =110012.

<p>&nbsp;&nbsp;&nbsp;Для лучшего понимания работы программы рекомендуем постро
ить трассировочную таблицу, наподобие предыдущей.

	<p><a><b><u>Коротко о главном:</u></b></a>


<p>&nbsp;&nbsp;&nbsp;Программирование перевода 10→2 и 2→10 основано на исполь
зовании операций над целыми числами: <b>div</b> — целочисленное деле
ние, <b>mod</b> — остаток от целочисленного деления.</p>

	<p><a><b><u>Вопросы и задания</u></b></a>

 

<p>&nbsp;&nbsp;&nbsp;1. Введите в компьютер и отладьте программу Numbers_2_10. Переведите сее помощью в десятичную систему счисления следующие двоичные
числа: 111110; 1111111; 100000. Проверьте правильность результатов.

<p>&nbsp;&nbsp;&nbsp;2. Введите в компьютер и отладьте программу Numbers_10_2. Переведитесее помощью в двоичную систему счисления следующие десятичные
числа: 255; 512; 1023. Проверьте правильность результатов.

	



<A NAME="2.2"></a>
<h3 align ="center">
	<b><a>2.2. Сложность алгоритмов</a></b>
</h3>

<P ALIGN="left">
	<p><I><b><a>Основные темы параграфа:</a></b></I>

<p>&nbsp;&nbsp;<I>*объемная сложность алгоритма;</I>
<p>&nbsp;&nbsp;<I>*временная сложность алгоритма;</I>

<p>&nbsp;&nbsp;<I>*алгоритмы перебора;</I>
<p>&nbsp;&nbsp;<I>*сложность алгоритмов перебора.</I>

<p>&nbsp;&nbsp;&nbsp;Традиционно принято оценивать степень сложности алгоритма
по объему используемых им основных ресурсов компьютера: процес
сорного времени и оперативной памяти. В связи с этим вводятся та
кие понятия, как временная сложность и объемная сложность алго
ритма.

<p>&nbsp;&nbsp;&nbsp;<b>Объемная сложность</b> связана с количеством данных, которые при
обработке нужно хранить в оперативной памяти. Проблемы могут
возникнуть при обработке больших массивов данных (числовых или
символьных). Если весь объем обрабатываемой информации не по
мещается одновременно в оперативную память, то эти данные при
ходится хранить на устройствах внешней памяти (дисках) и в про
цессе обработки перемещать частями из внешней памяти воператив
ную память и обратно. Поскольку время чтения и записи данных на
устройствах внешней памяти намного больше времени обмена про
цессора с оперативной памятью, то в целом время выполнения про
граммы существенно возрастает.

<p>&nbsp;&nbsp;&nbsp;<b>Временнёя сложность</b> связана с количеством операций, выполняе-
мых процессором в течение работы программы. Наибольшая часть про
цессорного времени тратится на выполнение циклов. Поэтому оценка
временной сложности производится по количеству повторений циклов.
Нетрудно понять, что при обработке массива данных количество повто
рений циклов связано с размером массива. Например, пусть вычисляет
ся сумма элементов массива Х, состоящего из N чисел: 
<p align ="center">&nbsp;&nbsp;&nbsp; s: = 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<b>for</b> &nbsp;&nbsp;&nbsp; i := 1 &nbsp;&nbsp;&nbsp; <b>to</b> &nbsp;&nbsp;&nbsp; N &nbsp;&nbsp;&nbsp; <b>do</b> &nbsp;&nbsp;&nbsp; s: = S + X[i];</P>


<p>&nbsp;&nbsp;&nbsp;В теле цикла выполняется две операции: сложение и присваивание. Число повторений цикла равно N. Следовательно, суммарное число выполняемых операций равно N - 2.
	Значит, время выполнения всего цикла будет пропорционально N2: Т-N-2. Втаком случае говорят, что <i>временная сложность алгоритма зависит линейно
от объема данных.</i> Во сколько раз возрастет N, во столько же раз
возрастет время выполнения программы.

Если вернуться к алгоритму поиска наибольшего и наименьшего
значений массива, то в нем также имеется один цикл, хотя тело цикла
содержит большее число операций. Но с увеличением размера массива (N) время выполнения программы будет также увеличиваться
линейно, т.е. пропорционально N. Следовательно, временная сложность алгоритмов суммирования массива и поиска в массиве максимального (минимального) элемента одинаковая — линейная.

Теперь оценим временную сложность алгоритма сортировки массива методом пузырька. По-прежнему обозначим через № размер
массива. Алгоритм содержит два вложенных цикла. Внешний цикл
имеет длину N - 1. Внутренний цикл с каждым повторением изме-
няет свою длину по убыванию: N - 1, N- 2, N- 3, ..., 2, 1. Суммарное число повторений цикла можно посчитать так: 


<p>&nbsp;&nbsp;&nbsp;вычислим среднюю длину внутреннего цикла:
[(N-П)+1]/2 = N/2;

<p>&nbsp;&nbsp;&nbsp;умножим эту величину на число повторений внешнего
цикла: (N - 1) N/2 = (N² - N)/2.

<p>&nbsp;&nbsp;&nbsp;Временная сложность алгоритма определяется слагаемым с наи
большей степенью: Т - N². В таком случае говорят,<i> что временная
сложность алгоритма сортировки методом пузырька имеет вто
рой порядок по объему данных</i>, т. е. пропорциональна квадрату N.
Например, если размер массива увеличить в 10 раз, то время сорти
ровки возрастет в 100 раз.


	<p><b><a>Сложность алгоритмов перебора</a></b>

<p>&nbsp;&nbsp;&nbsp;Большим классом задач, которые часто решаются на компьютере,
являются задачи поиска. Одну изтаких задач мы уже рассматривали:
поиск максимального элемента в массиве. Общий смысл задач поиска
сводится к следующему: из множества данных, хранящихся в памяти
компьютера, требуется выбрать нужные данные, удовлетворяющие
определенным условиям (критериям). Такой поиск осуществляется
перебором всех элементов структуры данных и их проверкой на удов
летворение условию поиска. Перебор, при котором просматриваются
все элементы структуры, называется <i>полным перебором.</i>

&nbsp;&nbsp;&nbsp;На примере алгоритма поиска максимального элемента мы зна
ем, что полный перебор элементов одномерного массива производит
ся с помощью одного цикла, число повторений которого пропорцио
нально размеру массива.


<p>&nbsp;&nbsp;&nbsp;Рассмотрим другой пример. В одномерном массиве Х заданы коор
динаты М точек, произвольно расположенных на вещественной чис
ловой оси. Точки пронумерованы. Их номера соответствуют номе
рам элементов в массиве Х. Нужно определить пару точек, расстоя
ние между которыми наибольшее.

&nbsp;&nbsp;&nbsp;Применяя метод перебора, эту задачу можно решать так: пере
брать все пары точек из N данных и определить номера тех точек,
расстояние между которыми наибольшее (наибольший модуль раз
ности координат). Такой полный перебор реализуется через два вло
женных цикла:

<IMG SRC="image/4.png" HEIGHT="300" ALIGN="center"><br>
</BODY>

<p>&nbsp;&nbsp;&nbsp;Но очевидно, что такое решение задачи нерационально. <i>Здесь
каждая пара точек будет просматриваться дважды,</i> например
при i = 1, j =2 и: i =2, j = 1. Для случая N = 100 циклы повторят вы
полнение 100. 100 = 10 000 раз.

&nbsp;&nbsp;&nbsp;Выполнение программы ускорится, если исключить повторения.
Исключитьтакже следует и совпадения значений i и j. Для исключе
ния повторений нужно в предыдущей программе изменить начало
внутреннего цикла с 1 на i + 1. Программа примет вид:

<IMG SRC="image/5.png" HEIGHT="300" ALIGN="center"><br>

<p>&nbsp;&nbsp;&nbsp;В таком алгоритме число повторений цикла будет равно
N(N - 1)/2. При N = 100 получается 4950. Рассмотренный вариант
алгоритма назовем <b>перебором без повторений.</b>

<p>&nbsp;&nbsp;&nbsp;<i>Замечание.</i> Конечно, эту задачу можно было решить и другим
способом, но в данном случае нас интересовал именно переборный
алгоритм. В случае же точек, расположенных не на прямой, а на
плоскости или в пространстве, поиск альтернативы переборному ал
горитму становится весьма проблематичным.

&nbsp;&nbsp;&nbsp;В следующей задаче требуется выбрать из массива Х без повторе
ний все тройки чисел, сумма которых равна десяти. В этом случае
алгоритм будет строиться из трех вложенных циклов. Внутренние
циклы имеют переменную длину.

<p><IMG SRC="image/6.png" HEIGHT="150" ALIGN="center">

<p>&nbsp;&nbsp;&nbsp;А теперь представьте, что из массива Х требуется выбрать всевоз
можные группы чисел, сумма которых равна десяти. Количество
чисел в группах может быть любым — от 1 до N. В этом случае коли
чество вариантов перебора резко возрастает, а сам алгоритм стано
вится нетривиальным.
<p>&nbsp;&nbsp;&nbsp;Казалось бы, ну и что? Компьютер работает быстро! И все же по
считаем. Число различных групп из М объектов (включая пустую)
составляет 2^N. При N = 100 это будет 2¹⁰⁰ = 10³⁰. Компьютер, работа
ющий со скоростью миллиард операций в секунду, будет осуще
ствлять такой перебор приблизительно 10 лет. Даже исключение пе
рестановочных повторений не сделает такой переборный алгоритм
практически осуществимым.
<p>&nbsp;&nbsp;&nbsp;Путь практической разрешимости подобных задач состоит в на
хождении способов исключения из перебора бесперспективных с
точки зрения условия задачи вариантов. Для некоторых задач это
удается сделать. К таким задачам относится задача поиска выхода
из лабиринта, задача о восьми ферзях (расставить на шахматной дос
ке восемь ферзей так, чтобы они не угрожали друг другу). Если бы
шахматные программы составлялись методом полного перебора все
возможных ходов, то ни один суперкомпьютер не смог бы в реальном
времени играть в шахматы. Очевидно, что в алгоритме программы
заложены знания стратегии и тактики игры в шахматы, которыми
владеют сильнейшие шахматисты, что существенно сокращает пе
ребор возможных ходов.
<p>&nbsp;&nbsp;&nbsp;Впечатляющим примером решения фундаментальной математи
ческой проблемы методом поиска является Проект GIMPS (Great
Internet Mersenne Prime Search), направленный на поиск простых
чисел Мерсенна — последовательности чисел, подчиняющихся закону 2ᵖ, где р — простое число. В ноябре 2001 года в рамках данно-
го проекта было найдено число Мерсенна, содержащее в своей деся
тичной записи более 4 млн цифр. Десятки тысяч компьютеров по
всему миру, отдавая часть своих вычислительных ресурсов, работа
ли над этой задачей два с половиной года.

	<p><B><u><a>Коротко о главном</b></u></a>

 

<p>&nbsp;&nbsp;&nbsp;В программировании используются два критерия сложности ал
горитма: объемная сложность и временная сложность.

<p>&nbsp;&nbsp;&nbsp;Объемная сложность связана с количеством данных, которые при
обработке нужно хранить в оперативной памяти.

<p>&nbsp;&nbsp;&nbsp;Временная сложность связана с количеством операций, выполня
емых процессором в течение работы программы; количество опера
ций пропорционально времени выполнения программы.

<p>&nbsp;&nbsp;&nbsp;Временная сложность оценивается как функция зависимости
числа операций от объема данных и может быть линейной, квадра
тичной и пр.

<p>&nbsp;&nbsp;&nbsp;Задача перебора: из множества данных, хранящихся в памяти
компьютера, требуется выбрать нужные данные, удовлетворяющие
определенным условиям (критериям).

<p>&nbsp;&nbsp;&nbsp;Временная сложность полного перебора может привести к превы
шению разумного времени выполнения программы на компьютере.

<p>&nbsp;&nbsp;&nbsp;Оптимизация алгоритма перебора состоит в исключении анализа
бесперспективных вариантов.


	<p><B><u><a>Вопросы и задания</b></u></a>

 

<p>&nbsp;&nbsp;&nbsp;1. Почему временная сложность алгоритма зависит от его объемной сложности?

<p>&nbsp;&nbsp;&nbsp;2. Составьте алгоритм поиска для следующей задачи: на координатной
плоскости заданы своими координатами М точек. Найти две самые удаленные друг от друга точки. Оцените временную сложность алгоритма.
Рассмотрите два варианта алгоритма: с полным и с неполным перебором
и сравните их.

<p>&nbsp;&nbsp;&nbsp;3. Составьте алгоритм для решения задачи, аналогичной предыдущей,
с учетом того что точки расположены в трехмерном пространстве.</p>



	<A NAME="2.3"></a>

<h3 align ="center">
<b><a>2.3 О языках программирования и  трансляторах</b><a/>
</h3>

<P ALIGN="left">
	<p><a><I><b>Основные темы параграфа:</b></I></a>

<p>&nbsp;&nbsp;<I>*системы программирования;</I>
<p>&nbsp;&nbsp;<I>*уровни языков программирования;</I>

<p>&nbsp;&nbsp;<I>*трансляция и трансляторы;</I>
<p>&nbsp;&nbsp;<I>*о двух способах трансляции;</I>
<p>&nbsp;&nbsp;<I>*работа компилятора;</I>
<p>&nbsp;&nbsp;<I>*работа интерпретатора.</I>


	<p>&nbsp;&nbsp;&nbsp;<b><a>Системы программирования</a></b>

<p>&nbsp;&nbsp;&nbsp;«Родным» языком ЭВМ является язык машинных команд (ЯМК).
Самые первые ламповые ЭВМ понимали только этот язык. В про
граммах на ЯМК данные обозначаются их адресами в памяти маши
ны, выполняемые операции — числовыми кодами. Программист
сам должен заботиться о расположении в памяти ЭВМ команд про
граммы и данных.

<p>&nbsp;&nbsp;&nbsp;Современные программисты так не работают. Для программирования на современных компьютерах применяются <b>системы программирования.</b> В учебнике 7 класса (глава 2) говорилось о том, что
программное обеспечение компьютера делится на три части:

<p>&nbsp;&nbsp;*системное ПО;
<p>&nbsp;&nbsp;*прикладное ПО;
<p>&nbsp;&nbsp;*системы программирования.


<p>&nbsp;&nbsp;&nbsp; С первыми двумя видами программного обеспечения вы уже зна
комы. Системное ПО — это прежде всего операционные системы,
сервисные программы. Прикладное ПО — это многочисленные ре
дакторы, электронные таблицы, информационные системы, мате
матические пакеты, экспертные системы и многое другое, с чем ра
ботает абсолютное большинство пользователей.

<p>&nbsp;&nbsp;&nbsp;Системы программирования предназначены для создания ком
пьютерных программ.

	<p>&nbsp;&nbsp;&nbsp;<b>Системы программирования(СП)</b> позволяют разрабатывать и исполнять на компьютере програмы, написанные на языках более высокого уровня,чем язык машинных команд.


<p>&nbsp;&nbsp;&nbsp;<b>Уровни языков программирования</b>

<p>&nbsp;&nbsp;&nbsp;Что понимается под уровнем языка программирования? Понятие уровня языка связано со степенью его удаленности от языка
процессора компьютера и приближенности к естественному челове
ческому языку, к формальному языку предметной области (чаще
всего — математики). Чем выше уровень, тем дальше язык от ком
пьютера и ближе к человеку. Этот принцип схематически отражен
на рис. 2.17.



<p><IMG SRC="image/8.png" HEIGHT="300" ALIGN="center">

<p>&nbsp;&nbsp;&nbsp;Язык машинных команд — это язык самого низкого уровня. Первые языки программирования, отличные от ЯМК, появились на машинах первого поколения, и назывались они <b>автокодами</b>.

<p>&nbsp;&nbsp;&nbsp;<b>Автокод -</b> это машинно-ориентированный язык символического программирования.


<p>&nbsp;&nbsp;&nbsp;Одна команда на автокоде соответствует одной машинной команде. Работая на автокоде, программист освобожден от необходимости
распределять память под программу и величины; ему не приходится
работать с адресами ячеек. Переменные величины и числовые кон
станты обозначаются так же, как в математике, коды операций 
мнемонически буквами.

<p>&nbsp;&nbsp;&nbsp;Начиная с машин третьего поколения, языки такого типа стали
называть ассемблерами. В наше время на ассемблере программиру
ют довольно редко. Это, как правило, делают системные програм
мисты.

<p>&nbsp;&nbsp;&nbsp;Аббревиатура ЯПВУ расшифровывается так: языки программирования высокого уровня. Сегодня большинство программистов ра
ботают именно на этих языках. Примеры языков высокого уровня:
Паскаль, Бейсик, Си (С), Фортран.

<p>&nbsp;&nbsp;&nbsp;Вот пример записи одной и той же команды сложения двух чисел
на трех языках разного уровня: ЯМК, автокоде и Паскале:

<p><IMG SRC="image/10.png" HEIGHT="150" ALIGN="center">


<p>&nbsp;&nbsp;&nbsp;Видно, как с повышением уровня языка
повышается «понятность» команды (по-английски слово «АП,» означает «сложить»).
Однако чем понятнее язык для человека, тем
он непонятнее для процессора компьютера.
Процессор понимает только ЯМК. Человеку
же легче писать программы на языках более
высокого уровня. Как же быть?



	<p>&nbsp;&nbsp;&nbsp;<b><a>Трансляция и трансляторы</a></b>

<p>&nbsp;&nbsp;&nbsp;Как сделать так, чтобы человек мог писать программы на автокоде или Паскале, а компьютер мог исполнять эти программы? Ответ
на поставленный вопрос такой же, как на вопрос «Как мне общаться
с японцем, если я не знаю японского языка?». Нужен переводчик!
По-английски «переводчик» — «translator».

<p>&nbsp;&nbsp;&nbsp;программы-переводчики с автокода, Паскаля,Фортрана и других языков на языке машинных команд называются <b>трансляторами</b>

<p>&nbsp;&nbsp;&nbsp;Таким образом, компьютер сам производит перевод под управлением программы-транслятора. Процесс перевода программы на
язык машинных команд называется трансляцией. Прежде чем выполнить, например, программу на Паскале, ее нужно оттранслировать. Трансляцию можно представить как спуск с верхней ступеньки языка на самую первую ступеньку — ЯМК (рис. 2.18).


<p><IMG SRC="image/13.png" HEIGHT="300" ALIGN="center">

<p>&nbsp;&nbsp;&nbsp;Транслятор является обязательным элементом любой системы
программирования. Первые СП включали в себя только транслятор.
Затем к транслятору стали добавляться различные сервисные средства: текстовые редакторы, отладчики, системы обслуживания про-
граммных библиотек, средства организации дружественного интерфейса с пользователем.

<p>&nbsp;&nbsp;&nbsp;Наиболее удобными для пользователя стали системы программирования, созданные на персональных компьютерах.

<p>&nbsp;&nbsp;&nbsp;Язык программирования, с которым работает СП, называется ее
<i>входным языком.</i> Системы программирования именуются по названию своего входного языка. Например: «система Бейсик», «система
Паскаль», «система Фортран». Иногда в название систем включаются префиксы, обозначающие, например, ее фирменное происхождение. Очень популярны системы с приставкой «Турбо»: Турбо Паскаль, Турбо С и др. Это системы программирования, разработанные
фирмой Вогland.

	<p>&nbsp;&nbsp;&nbsp; <b><a>О двух способах трансляции</a></b>

<p>&nbsp;&nbsp;&nbsp;Реализовать тот или иной язык программирования на компьютере — это значит создать транслятор с этого языка для данного компьютера. Существуют два принципиально различных метода трансляции. Они называются компиляция и интерпретация.



<p>&nbsp;&nbsp;&nbsp;Для объяснения различия можно предложить такую аналогию:
представьте себе, что иностранный лектор должен выступить перед
аудиторией на незнакомом для слушателей языке. Требуется перевод, который можно организовать двумя способами:

<p>&nbsp;&nbsp;&nbsp;1) полный предварительный перевод: лектор заранее передает
текст выступления переводчику, тот записывает перевод, размножает его и раздает слушателям (после этого лектор может уже и не
выступать);

<p>&nbsp;&nbsp;&nbsp;2) синхронный перевод: лектор читает доклад, переводчик одновременно с ним, слово за словом, переводит выступление.


<p>&nbsp;&nbsp;&nbsp;<i>Компиляция является аналогом полного предварительного перевода; интерпретация — аналог синхронного перевода.</i> Транслятор, работающий по принципу компиляции, называется <b>компилятором</b>. Транслятор, работающий методом интерпретации, называется <b>интерпретатором.</b>

	<p>&nbsp;&nbsp;&nbsp;<b><a>Работа компилятора</a></b>

<p>&nbsp;&nbsp;&nbsp;При компиляции в память компьютера загружается программа-компилятор. Она воспринимает текст программы на ЯПВУ как
исходную информацию. Компилятор производит синтаксический
контроль программы и при обнаружении ошибок выводит диагностические сообщения. Если ошибок нет, то результатом компиляции
является программа на языке машинных команд.

<p>&nbsp;&nbsp;&nbsp;Затем компилятор удаляется из оперативной памяти. В памяти
остается только программа на ЯМК, которая выполняется для получения результатов.

<p>&nbsp;&nbsp;&nbsp;На рисунке 2.19 схематически показан процесс выполнения программы на ЯПВУ с использованием компиляции. Прямоугольниками изображены программы в машинных кодах, овалами — обрабатываемая и конечная информация.


<p><IMG SRC="image/15.png" HEIGHT="300" ALIGN="center">


<p>&nbsp;&nbsp;&nbsp;Конечно, компиляция с автокода (ассемблера) много проще, чем
с языков высокого уровня. Для этой процедуры часто применяют
специальный термин — ассемблирование. А под словом «ассемблер» понимается не только язык программирования, но и транслятор с него.

	<p>&nbsp;&nbsp;&nbsp;<b><a>Работа интерпретатора</a></b>

<p>&nbsp;&nbsp;&nbsp;Интерпретатор в течение всего времени работы программы находится во внутренней памяти (иногда для этого используется ПЗУ).
В ОЗУ помещается программа на ЯПВУ. Интерпретатор «читает» ее
первый оператор, переводит его в машинные команды и тут же организует выполнение этих команд. Затем переходит к переводу и выполнению следующего оператора, и так до конца программы. При этом результаты предыдущих переводов в памяти не сохраняются.
При повторном выполнении одного и того же оператора в цикле он
снова будет транслироваться. Перед трансляцией каждого оператора происходит его синтаксический анализ.

<p>&nbsp;&nbsp;&nbsp;На рисунке 2.20 схематически показан процесс выполнения программы на ЯПВУ с использованием интерпретатора.

<p><IMG SRC="image/16.png" HEIGHT="300" ALIGN="center">


<p>&nbsp;&nbsp;&nbsp;Таким образом, при компиляции трансляция и исполнение программы идут последовательно друг за другом. При интерпретации —
параллельно.

<p>&nbsp;&nbsp;&nbsp;Один раз откомпилированная программа может быть сохранена
во внешней памяти и затем многократно выполнена. На компиляцию машинное время тратиться больше не будет. Программа на интерпретируемом языке при каждом выполнении подвергается повторной трансляции. Кроме того, интерпретатор может занимать
значительное место в оперативной памяти.

<p>&nbsp;&nbsp;&nbsp;Из-за указанных причин использование компиляторов удобнее
для больших программ, требующих быстрого счета и большого объема памяти. Программы на Паскале, Си, Фортране всегда компилируются. Язык Бейсик часто реализуется через интерпретатор.

	<p>&nbsp;&nbsp;&nbsp;<a><b><u>Коротко о главном</a></u></b>

 

<p>&nbsp;&nbsp;&nbsp;Для разработки программ программисты используют системы
программирования (СП).

<p>&nbsp;&nbsp;&nbsp;Язык программирования, с которым позволяет работать данная
СП, называется ее входным языком.
Язык процессора компьютера — это язык машинных команд —

ЯМК.

<p>&nbsp;&nbsp;&nbsp;Уровень языка программирования определяется степенью его
удаленности от ЯМК (чем дальше, тем выше уровень).


<p>&nbsp;&nbsp;&nbsp;Автокод (ассемблер) — это машинно-ориентированный язык символического программирования.

<p>&nbsp;&nbsp;&nbsp;Наиболее удобным средством программирования являются языки высокого уровня (ЯПВУ). Сегодня с ними работает большинство
программистов.

<p>&nbsp;&nbsp;&nbsp;Трансляция — это процесс перевода текста программы на язык
машинных команд. Программа-переводчик называется транслятором.

<p>&nbsp;&nbsp;&nbsp;Существуют два способа трансляции: компиляция и интерпретация.
При компиляции сначала весь текст программы переводится на ЯМК,
затем производится ее исполнение. При интерпретации перевод и исполнение происходят параллельно.

	<p><a><b><u>Вопросы и задания</u></b></a>
<p>&nbsp;&nbsp;&nbsp;1. Что такое язык программирования?
<p>&nbsp;&nbsp;&nbsp;2. Что обозначает понятие «уровень языка программирования» ?
<p>&nbsp;&nbsp;&nbsp;3. К какому уровню относятся языки типа автокод (ассемблер)?

<p>&nbsp;&nbsp;&nbsp;4. Почему языки программирования высокого уровня называют машинно-независимыми языками?

<p>&nbsp;&nbsp;&nbsp;5. Какие из языков программирования высокого уровня вы знаете?
<p>&nbsp;&nbsp;&nbsp;6. Что такое трансляция? Что такое транслятор?
<p>&nbsp;&nbsp;&nbsp;7. В чем различие между компиляцией и интерпретацией?
</p>


 
 <h1>Тест по параграфу 2.1</h1>

<section class="main">

<form name="quiz" action="javascript:check();" class="quizform">

<div class="quizsection">


	<h2>Как называется длинный целый тип?</h2>
	
	<div class="answer">
		<input name="q1" value="value2" id="value1" type="radio"  /> longint
	</div>

	<div class="answer">
		<input name="q1" value="value1" id="value2" type="radio" /> int
	</div>

	<div class="answer">
		<input name="q1" value="value1" id="value3" type="radio" /> string
	</div>

</div>

<div class="quizsection">

	<h2>для чего нужна операция div?</h2>

	<div class="answer">
		<input name="q2" value="value1" id="value1" type="radio"  /> Умножение
	</div>

	<div class="answer">
		<input name="q2" value="value2" id="value2" type="radio" /> Деление без остатка  
	</div>

	<div class="answer">
		<input name="q2" value="value1" id="value3" type="radio" /> Деление с остатком
	</div>

	<div class="answer">
		<input name="q2" value="value1" id="value4" type="radio" /> Вычитание
	</div>

	<div class="answer">
		<input name="q2" value="value1" id="value5" type="radio" /> Сложение
	</div>


</div>

<h1>Тест по параграфу 2.2</h1>

<section class="main">

<form name="quiz" action="javascript:check();" class="quizform">

<div class="quizsection">


	<h2>С чем связана объемная сложность?</h2>
	
	<div class="answer">
		<input name="q3" value="value1" id="value1" type="radio"  /> С временем обработки
	</div>

	<div class="answer">
		<input name="q3" value="value1" id="value2" type="radio" /> С количеством операций
	</div>

	<div class="answer">
		<input name="q3" value="value2" id="value3" type="radio" /> С количеством данных
	</div>

</div>

<div class="quizsection">

	<h2>С чем связана временная сложность?</h2>

	<div class="answer">
		<input name="q4" value="value1" id="value1" type="radio"  /> С объемом данный
	</div>

	<div class="answer">
		<input name="q4" value="value2" id="value2" type="radio" /> С количеством операций
	</div>

	<div class="answer">
		<input name="q4" value="value1" id="value3" type="radio" /> С временем обработки
	</div>



</div>

<div class="quizsection">

	<h2>Какой проект является примером решения фундаментальной математической проблемы методм поиска?</h2>

	<div class="answer">
		<input name="q5" value="value2" id="value1" type="radio" /> GIMPS
	</div>

	<div class="answer">
		<input name="q5" value="value1" id="value2" type="radio" /> Pascal
	</div>

	<div class="answer">
		<input name="q5" value="value1" id="value3" type="radio" /> Google
	</div>



</div>
<div class="quizsection">

	<h2>Какой критерий слжности используется в программировнии</h2>

	<div class="answer">
		<input name="q6" value="value1" id="value1" type="radio"  /> Большая сложность 
	</div>

	<div class="answer">
		<input name="q6" value="value2" id="value2" type="radio" /> Временная сложность 
	</div>

	<div class="answer">
		<input name="q6" value="value1" id="value3" type="radio" /> Средняя сложность
	</div>



</div>



<h1>Тест по параграфу 2.3</h1>

<section class="main">

<form name="quiz" action="javascript:check();" class="quizform">

<div class="quizsection">


	<h2>Какой родной язык ЭВМ?</h2>
	
	<div class="answer">
		<input name="q7" value="value2" id="value1" type="radio"  /> ЯМК
	</div>

	<div class="answer">
		<input name="q7" value="value1" id="value2" type="radio" /> Pascal
	</div>

	<div class="answer">
		<input name="q7" value="value1" id="value3" type="radio" /> BIOS
	</div>

</div>

<div class="quizsection">

	<h2>Как называются программы-переводчики с автокода?</h2>

	<div class="answer">
		<input name="q8" value="value1" id="value1" type="radio"  /> Транслитор 
	</div>

	<div class="answer">
		<input name="q8" value="value2" id="value2" type="radio" /> Транслятор
	</div>

	<div class="answer">
		<input name="q8" value="value1" id="value3" type="radio" /> Обработчик
	</div>



</div>
<div class="quizsection">

	<h2>Как называется один из способов перевода?</h2>

	<div class="answer">
		<input name="q9" value="value1" id="value1" type="radio" /> Несинхронный перевод 
	</div>

	<div class="answer">
		<input name="q9" value="value2" id="value2" type="radio" /> Синхронный перевод
	</div>

	<div class="answer">
		<input name="q9" value="value1" id="value3" type="radio" /> Сложный перевод
	</div>



</div>
<input value="Проверить" type="submit" /> <input value="Обновить" type="reset" />

</form>

</section>

<script type="text/javascript">// <![CDATA[

   var result;
   
   function check()

   {

      var question;
      var value1;
      var value2;
      
      
      question = 1;
      value1 = 0;
      value2 = 0;
      
      
      result = "";

      var choice;
      
      for (question = 1; question <= 7; question++) {
      
         var q = document.forms['quiz'].elements['q'+question];

            for (var i = 0; i < q.length; i++) {
               if (q[i].checked) {
                  choice = q[i].value;
               }
            }

            if (choice == "value1") {
               value1++;
            }

            if (choice == "value2") {
               value2++;
            }


         }

      if (value2 == 0) {

         // Нет правильных ответов
         result = "ocenka2";

      }
	else if (value2 == 1) {

         // Один правильный ответ
         result = "ocenka2";

      }
	else if (value2 == 2) {

         // Один правильный ответ
         result = "ocenka2";

      }
	else if (value2 == 3) {

         // Один правильный ответ
         result = "ocenka2";

      }
      else if (value2 == 4) {

         // Один правильный ответ
         result = "ocenka3";

      }
	else if (value2 == 5) {

         // Один правильный ответ
         result = "ocenka3";

      }

      else if (value2 == 6) {

         // Два правильных ответа
         result = "ocenka4";

      }

      else if (value2 == 7) {

         // Три правильных ответа
         result = "ocenka5";

      }


      else {
         result = "404";
      }

      window.location = result + '.html';

   }

// ]]></script>

</HTML>
