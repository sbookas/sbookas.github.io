<HTML>

<HEAD>
<meta charset = "UTF-8"> 
<TITLE>Дополнение к главе 2</TITLE>
</HEAD>


<BODY>



<h1 align ="center" color = "#1581e6" ><B>Дополнение к главе II</B></h1>

<P ALIGN="left"><FONT COLOR="#1581e6">
<h2><A HREF="#2.1.HTML">2.1 Программирование перевода чисел из одной системы счисления в другую</A></h2> </FONT>
</p>


<P ALIGN="left"><FONT COLOR="#1581e6">
<h2><A HREF="#2.2">2.2 Сложность алгоритмов</A></h2></FONT>
</p>



<P ALIGN="left"><FONT COLOR="#1581e6">
<h2><A HREF="#2.3">2.3 О языках программирования и трансляторах</A></h2></FONT>
</p>


<P ALIGN="left"><FONT COLOR="#1581e6">
<h2><A HREF="#2.4">2.4 История языков программирования</A></h2></FONT>
</p>



<A NAME="2.1.HTML">

<h1 align ="center">
<b>2.1 Программирование перевода чисел из одной системы счисления в другую</b>
</h1>

<P ALIGN="left">
<p><font size = "3"><I><b>Основные темы параграфа:</b></I></font>

<p><font size = "3">&nbsp;&nbsp;<I>*Перевод двоичного числа в десятичную систему счисления;</I></font>

<p><font size = "3">&nbsp;&nbsp;<I>*Перевод десятичного числа в двоичную систему счисления.</I></font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;В $ 18 учебника для 8 класса рассказано о двоичной системе счисления, 
которая используется в компьютере для представления чисел и выполнения вычислений с ними. 
Там же описаны правила, по которым можно вручную выполнить перевод двоичных чисел в десятичную 
систему счисления и обратный перевод — десятичных чисел
в двоичные. Рассмотрим программы на Паскале для автоматического перевода чисел из одной системы 
счисления в другую. Ограничимся переводом целых чисел.</font>


<p>&nbsp;&nbsp;&nbsp;<b><font size = "4">Программа перевода двоичного числа в десятичную систему
счисления</font></b>

<p><font size = "4">&nbsp;&nbsp;&nbsp;Рассмотрим программу на Паскале, по которой происходит пере-
вод целого двоичного числа в десятичную систему.</font>

<IMG SRC="image/1.png" HEIGHT="500"><br>

<p>&nbsp;&nbsp;&nbsp;<font size = "4">В программе использованы следующие переменные:
<p>&nbsp;&nbsp;&nbsp;№2 — целое двоичное число — исходное данное;
<p>&nbsp;&nbsp;&nbsp;№10 — десятичное число — результат;</font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;Тип <i>longint</i> — длинный целый тип. Значения величин этого типа
лежат в диапазоне от —2 147 483 648 до 2 147 483 647. Значит, данная программа может работать с числами, не более чем 9-значными.

<p>&nbsp;&nbsp;&nbsp;В этой программе используются две незнакомые вам операции
с целыми числами. Операция <b>div</b> — целочисленное деление. Дели-
мое и делитель являются целыми числами, а результат — целая
часть частного. Например: 7 <b>div</b> 2 = 3. Для отбрасывания младше-
го разряда целого числа используется целочисленное деление на 10.Например: 1234 
<b>div</b> 10 = 123 — отбрасывается младший разряд.

<p>&nbsp;&nbsp;&nbsp;Операция <b>mod</b> дает остаток от целочисленного деления. Напри-
мер: 7 <b>mod</b> 2 = 1. Для получения младшего разряда целого числа
вычисляется остаток от целочисленного деления на 10. Например:
1234 <b>mod</b> 10 = 4 — выделяется разряд единиц.</font>


<p><font size = "4">&nbsp;&nbsp;&nbsp;<b><u>Пример</u></b>. При переводе по данной программе двоичного числа
1101, в десятичную систему на экране увидим:

<p>&nbsp;&nbsp;&nbsp;№2=1101

<p>&nbsp;&nbsp;&nbsp;№0=13

<p>&nbsp;&nbsp;&nbsp;Следовательно, в итоге получили: 1 101,=13.

<p>&nbsp;&nbsp;&nbsp;Для лучшего понимания работы программы внимательно изучи-
те приведенную далее трассировочную таблицу. Она отражает изме
нения значений переменных на каждом шаге выполнения алгорит-
ма, реализованного в программе.
</font>
<P ALIGN="CENTER">
<IMG SRC="image/2.png" HEIGHT="1000" ALIGN="center"><br>
</P>
<p><b><font size = "4">Программа перевода десятичного числа в двоичную систему
счисления</b>

<p>Теперь познакомьтесь с программой перевода целого десятичного
числа в двоичную систему счисления.</font> 

<P ALIGN="left">
<IMG SRC="image/3.png" HEIGHT="500" ALIGN="center"><br>
</P><br>
<p><font size = "4"> Здесь использованы те же обозначения, что и в предыдущей про-
грамме. Исходными данными являются: N10 — десятичное число.
Результат получается в переменной N2 — число в системе с основани-
ем 2.

<p>В алгоритме используется циклс постусловием <b>(гереаt ... ип+11).</b>
Цикл повторяется до выполнения условия: N10 = 0.

<p>&nbsp;&nbsp;&nbsp;<b><i>Пример</i></b> использования программы. Переведем число 25 в двоич-
ную систему счисления. Работа программы на экране компьютера
отразится следующим образом:

<p>&nbsp;&nbsp;&nbsp;N10=25

<p>&nbsp;&nbsp;&nbsp;N2=11001

<p>&nbsp;&nbsp;&nbsp;Следовательно, в результате получили: 25 =11001<font size = "1">2</font>.

<p>&nbsp;&nbsp;&nbsp;Для лучшего понимания работы программы рекомендуем постро
ить трассировочную таблицу, наподобие предыдущей.

<p><font size = "5"><b><u>Коротко о главном:</u></b></font>


<p>&nbsp;&nbsp;&nbsp;<font size = "4">Программирование перевода 10→2 и 2→10 основано на исполь
зовании операций над целыми числами: <b>div</b> — целочисленное деле
ние, <b>mod</b> — остаток от целочисленного деления.</p>

<p><font size = "5"><b><u>Вопросы и задания</u></b></font>

 

<p>&nbsp;&nbsp;&nbsp;1. Введите в компьютер и отладьте программу Numbers_2_10. Переведи-
те сее помощью в десятичную систему счисления следующие двоичные
числа: 111110; 1111111; 100000. Проверьте правильность результатов.

<p>&nbsp;&nbsp;&nbsp;2. Введите в компьютер и отладьте программу Numbers_10_2. Переведи-
тесее помощью в двоичную систему счисления следующие десятичные
числа: 255; 512; 1023. Проверьте правильность результатов.





<A NAME="2.2">
<h1 align ="center">
<b>2.2. Сложность алгоритмов</b>
</h1>

<P ALIGN="left">
<p><font size = "4"><I><b>Основные темы параграфа:</b></I></font>

<p><font size = "4">&nbsp;&nbsp;<I>*объемная сложность алгоритма;</I></font>
<p><font size = "4">&nbsp;&nbsp;<I>*временная сложность алгоритма;</I></font>

<p><font size = "4">&nbsp;&nbsp;<I>*алгоритмы перебора;</I></font>
<p><font size = "4">&nbsp;&nbsp;<I>*сложность алгоритмов перебора.</I></font>


<p><font size = "4">&nbsp;&nbsp;&nbsp;Традиционно принято оценивать степень сложности алгоритма
по объему используемых им основных ресурсов компьютера: процес
сорного времени и оперативной памяти. В связи с этим вводятся та
кие понятия, как временная сложность и объемная сложность алго
ритма.</font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;<b>Объемная сложность</b> связана с количеством данных, которые при
обработке нужно хранить в оперативной памяти. Проблемы могут
возникнуть при обработке больших массивов данных (числовых или
символьных). Если весь объем обрабатываемой информации не по
мещается одновременно в оперативную память, то эти данные при
ходится хранить на устройствах внешней памяти (дисках) и в про
цессе обработки перемещать частями из внешней памяти воператив
ную память и обратно. Поскольку время чтения и записи данных на
устройствах внешней памяти намного больше времени обмена про
цессора с оперативной памятью, то в целом время выполнения про
граммы существенно возрастает.</font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;<b>Временнёя сложность</b> связана с количеством операций, выполняе-
мых процессором в течение работы программы. Наибольшая часть про
цессорного времени тратится на выполнение циклов. Поэтому оценка
временной сложности производится по количеству повторений циклов.
Нетрудно понять, что при обработке массива данных количество повто
рений циклов связано с размером массива. Например, пусть вычисляет
ся сумма элементов массива Х, состоящего из N чисел: </font>
<font size = "4"><p align ="center">&nbsp;&nbsp;&nbsp; s: = 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<b>for</b> &nbsp;&nbsp;&nbsp; i := 1 &nbsp;&nbsp;&nbsp; <b>to</b> &nbsp;&nbsp;&nbsp; N &nbsp;&nbsp;&nbsp; <b>do</b> &nbsp;&nbsp;&nbsp; s: = S + X[i];</font></P>


<p><font size = "4">&nbsp;&nbsp;&nbsp;В теле цикла выполняется две операции: сложение и присваива-
ние. Число повторений цикла равно N. Следовательно, суммарное число выполняемых операций равно N - 2. Значит, время выполне-
ния всего цикла будет пропорционально N2: Т-N-2. Втаком слу-
чае говорят, что <i>временная сложность алгоритма зависит линейно
от объема данных.</i> Во сколько раз возрастет N, во столько же раз
возрастет время выполнения программы.

Если вернуться к алгоритму поиска наибольшего и наименьшего
значений массива, то в нем также имеется один цикл, хотя тело цикла
содержит большее число операций. Но с увеличением размера мас-
сива (N) время выполнения программы будет также увеличиваться
линейно, т.е. пропорционально N. Следовательно, временная слож-
ность алгоритмов суммирования массива и поиска в массиве макси-
мального (минимального) элемента одинаковая — линейная.

Теперь оценим временную сложность алгоритма сортировки мас-
сива методом пузырька. По-прежнему обозначим через № размер
массива. Алгоритм содержит два вложенных цикла. Внешний цикл
имеет длину N - 1. Внутренний цикл с каждым повторением изме-
няет свою длину по убыванию: N - 1, N- 2, N- 3, ..., 2, 1. Суммар-
ное число повторений цикла можно посчитать так: </font>


<p>&nbsp;&nbsp;&nbsp;вычислим среднюю длину внутреннего цикла:
[(N-П)+1]/2 = N/2;

<p>&nbsp;&nbsp;&nbsp;умножим эту величину на число повторений внешнего
цикла: (N - 1) N/2 = (N² - N)/2.

<p>&nbsp;&nbsp;&nbsp;<font size = "4">Временная сложность алгоритма определяется слагаемым с наи
большей степенью: Т - N². В таком случае говорят,<i> что временная
сложность алгоритма сортировки методом пузырька имеет вто
рой порядок по объему данных</i>, т. е. пропорциональна квадрату N.
Например, если размер массива увеличить в 10 раз, то время сорти
ровки возрастет в 100 раз.</font>


<p><b>Сложность алгоритмов перебора</b>

<p>&nbsp;&nbsp;&nbsp;<font size = "4">Большим классом задач, которые часто решаются на компьютере,
являются задачи поиска. Одну изтаких задач мы уже рассматривали:
поиск максимального элемента в массиве. Общий смысл задач поиска
сводится к следующему: из множества данных, хранящихся в памяти
компьютера, требуется выбрать нужные данные, удовлетворяющие
определенным условиям (критериям). Такой поиск осуществляется
перебором всех элементов структуры данных и их проверкой на удов
летворение условию поиска. Перебор, при котором просматриваются
все элементы структуры, называется <i>полным перебором.</i>

<font size = "4">&nbsp;&nbsp;&nbsp;На примере алгоритма поиска максимального элемента мы зна
ем, что полный перебор элементов одномерного массива производит
ся с помощью одного цикла, число повторений которого пропорцио
нально размеру массива.</font>


<p><font size = "4">&nbsp;&nbsp;&nbsp;Рассмотрим другой пример. В одномерном массиве Х заданы коор
динаты М точек, произвольно расположенных на вещественной чис
ловой оси. Точки пронумерованы. Их номера соответствуют номе
рам элементов в массиве Х. Нужно определить пару точек, расстоя
ние между которыми наибольшее.

&nbsp;&nbsp;&nbsp;Применяя метод перебора, эту задачу можно решать так: пере
брать все пары точек из N данных и определить номера тех точек,
расстояние между которыми наибольшее (наибольший модуль раз
ности координат). Такой полный перебор реализуется через два вло
женных цикла:</font>

<IMG SRC="image/4.png" HEIGHT="300" ALIGN="center"><br>
</BODY>

<p><font size = "4">&nbsp;&nbsp;&nbsp;Но очевидно, что такое решение задачи нерационально. <i>Здесь
каждая пара точек будет просматриваться дважды,</i> например
при i = 1, j =2 и: i =2, j = 1. Для случая N = 100 циклы повторят вы
полнение 100. 100 = 10 000 раз.

&nbsp;&nbsp;&nbsp;Выполнение программы ускорится, если исключить повторения.
Исключитьтакже следует и совпадения значений i и j. Для исключе
ния повторений нужно в предыдущей программе изменить начало
внутреннего цикла с 1 на i + 1. Программа примет вид:</font>

<IMG SRC="image/5.png" HEIGHT="300" ALIGN="center"><br>

<p><font size = "4">&nbsp;&nbsp;&nbsp;В таком алгоритме число повторений цикла будет равно
N(N - 1)/2. При N = 100 получается 4950. Рассмотренный вариант
алгоритма назовем <b>перебором без повторений.</b></font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;<i>Замечание.</i> Конечно, эту задачу можно было решить и другим
способом, но в данном случае нас интересовал именно переборный
алгоритм. В случае же точек, расположенных не на прямой, а на
плоскости или в пространстве, поиск альтернативы переборному ал
горитму становится весьма проблематичным.

&nbsp;&nbsp;&nbsp;В следующей задаче требуется выбрать из массива Х без повторе
ний все тройки чисел, сумма которых равна десяти. В этом случае
алгоритм будет строиться из трех вложенных циклов. Внутренние
циклы имеют переменную длину.</font>

<p><IMG SRC="image/6.png" HEIGHT="150" ALIGN="center">

<p><font size = "4">&nbsp;&nbsp;&nbsp;А теперь представьте, что из массива Х требуется выбрать всевоз
можные группы чисел, сумма которых равна десяти. Количество
чисел в группах может быть любым — от 1 до N. В этом случае коли
чество вариантов перебора резко возрастает, а сам алгоритм стано
вится нетривиальным.
<p>&nbsp;&nbsp;&nbsp;Казалось бы, ну и что? Компьютер работает быстро! И все же по
считаем. Число различных групп из М объектов (включая пустую)
составляет 2^N. При N = 100 это будет 2¹⁰⁰ = 10³⁰. Компьютер, работа
ющий со скоростью миллиард операций в секунду, будет осуще
ствлять такой перебор приблизительно 10 лет. Даже исключение пе
рестановочных повторений не сделает такой переборный алгоритм
практически осуществимым.
<p>&nbsp;&nbsp;&nbsp;Путь практической разрешимости подобных задач состоит в на
хождении способов исключения из перебора бесперспективных с
точки зрения условия задачи вариантов. Для некоторых задач это
удается сделать. К таким задачам относится задача поиска выхода
из лабиринта, задача о восьми ферзях (расставить на шахматной дос
ке восемь ферзей так, чтобы они не угрожали друг другу). Если бы
шахматные программы составлялись методом полного перебора все
возможных ходов, то ни один суперкомпьютер не смог бы в реальном
времени играть в шахматы. Очевидно, что в алгоритме программы
заложены знания стратегии и тактики игры в шахматы, которыми
владеют сильнейшие шахматисты, что существенно сокращает пе
ребор возможных ходов.
<p>&nbsp;&nbsp;&nbsp;Впечатляющим примером решения фундаментальной математи
ческой проблемы методом поиска является Проект GIMPS (Great
Internet Mersenne Prime Search), направленный на поиск простых
чисел Мерсенна — последовательности чисел, подчиняющихся закону 2ᵖ, где р — простое число. В ноябре 2001 года в рамках данно-
го проекта было найдено число Мерсенна, содержащее в своей деся
тичной записи более 4 млн цифр. Десятки тысяч компьютеров по
всему миру, отдавая часть своих вычислительных ресурсов, работа
ли над этой задачей два с половиной года.

<p><B><u><font size = "5">Коротко о главном</b></u></font>

 

<p><font size = "4">&nbsp;&nbsp;&nbsp;В программировании используются два критерия сложности ал
горитма: объемная сложность и временная сложность.</font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;Объемная сложность связана с количеством данных, которые при
обработке нужно хранить в оперативной памяти.</font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;Временная сложность связана с количеством операций, выполня
емых процессором в течение работы программы; количество опера
ций пропорционально времени выполнения программы.</font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;Временная сложность оценивается как функция зависимости
числа операций от объема данных и может быть линейной, квадра
тичной и пр.</font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;Задача перебора: из множества данных, хранящихся в памяти
компьютера, требуется выбрать нужные данные, удовлетворяющие
определенным условиям (критериям).</font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;Временная сложность полного перебора может привести к превы
шению разумного времени выполнения программы на компьютере.</font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;Оптимизация алгоритма перебора состоит в исключении анализа
бесперспективных вариантов.</font>


<p><B><u><font size = "5">Вопросы и задания</b></u></font>

 

<p>&nbsp;&nbsp;&nbsp;<font size = "4">1. Почему временная сложность алгоритма зависит от его объемной слож-
ности?</font>

<p>&nbsp;&nbsp;&nbsp;<font size = "4">2. Составьте алгоритм поиска для следующей задачи: на координатной
плоскости заданы своими координатами М точек. Найти две самые уда-
ленные друг от друга точки. Оцените временную сложность алгоритма.
Рассмотрите два варианта алгоритма: с полным и с неполным перебором
и сравните их.</font>

<p>&nbsp;&nbsp;&nbsp;<font size = "4">3. Составьте алгоритм для решения задачи, аналогичной предыдущей,
с учетом того что точки расположены в трехмерном пространстве.</font></p>



<A NAME="2.3">

<h1 align ="center">
<b>2.3 О языках программирования и  трансляторах</b>
</h1>

<P ALIGN="left">
<p><font size = "4"><I><b>Основные темы параграфа:</b></I></font>

<p><font size = "4">&nbsp;&nbsp;<I>*системы программирования;</I></font>
<p><font size = "4">&nbsp;&nbsp;<I>*уровни языков программирования;</I></font>

<p><font size = "4">&nbsp;&nbsp;<I>*трансляция и трансляторы;</I></font>
<p><font size = "4">&nbsp;&nbsp;<I>*о двух способах трансляции;</I></font>
<p><font size = "4">&nbsp;&nbsp;<I>*работа компилятора;</I></font>
<p><font size = "4">&nbsp;&nbsp;<I>*работа интерпретатора.</I></font>


<p><font size = "4">&nbsp;&nbsp;&nbsp;<b>Системы программирования</b></font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;«Родным» языком ЭВМ является язык машинных команд (ЯМК).
Самые первые ламповые ЭВМ понимали только этот язык. В про
граммах на ЯМК данные обозначаются их адресами в памяти маши
ны, выполняемые операции — числовыми кодами. Программист
сам должен заботиться о расположении в памяти ЭВМ команд про
граммы и данных.

<p><font size = "4">&nbsp;&nbsp;&nbsp;Современные программисты так не работают. Для программирования на современных компьютерах применяются <b>системы программирования.</b> В учебнике 7 класса (глава 2) говорилось о том, что
программное обеспечение компьютера делится на три части:

<p><font size = "4">&nbsp;&nbsp;*системное ПО;</font>
<p><font size = "4">&nbsp;&nbsp;*прикладное ПО;</font>
<p><font size = "4">&nbsp;&nbsp;*системы программирования.</font>


<p><font size = "4">&nbsp;&nbsp;&nbsp; С первыми двумя видами программного обеспечения вы уже зна
комы. Системное ПО — это прежде всего операционные системы,
сервисные программы. Прикладное ПО — это многочисленные ре
дакторы, электронные таблицы, информационные системы, мате
матические пакеты, экспертные системы и многое другое, с чем ра
ботает абсолютное большинство пользователей.

<p><font size = "4">&nbsp;&nbsp;&nbsp;Системы программирования предназначены для создания ком
пьютерных программ.

<p><IMG SRC="image/7.png" HEIGHT="200" ALIGN="center">


<p><font size = "4">&nbsp;&nbsp;&nbsp;<b>Уровни языков программирования</b></font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;Что понимается под уровнем языка программирования? Понятие уровня языка связано со степенью его удаленности от языка
процессора компьютера и приближенности к естественному челове
ческому языку, к формальному языку предметной области (чаще
всего — математики). Чем выше уровень, тем дальше язык от ком
пьютера и ближе к человеку. Этот принцип схематически отражен
на рис. 2.17.</font>



<p><IMG SRC="image/8.png" HEIGHT="300" ALIGN="center">

<p><font size = "4">&nbsp;&nbsp;&nbsp;Язык машинных команд — это язык самого низкого уровня. Пер-
вые языки программирования, отличные от ЯМК, появились на ма-
шинах первого поколения, и назывались они <b>автокодами</b>.</font>

<p><IMG SRC="image/9.png" HEIGHT="200" ALIGN="center">


<p><font size = "4">&nbsp;&nbsp;&nbsp;Одна команда на автокоде соответствует одной машинной коман-
де. Работая на автокоде, программист освобожден от необходимости
распределять память под программу и величины; ему не приходится
работать с адресами ячеек. Переменные величины и числовые кон
станты обозначаются так же, как в математике, коды операций 
мнемонически буквами.</font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;Начиная с машин третьего поколения, языки такого типа стали
называть ассемблерами. В наше время на ассемблере программиру
ют довольно редко. Это, как правило, делают системные програм
мисты.</font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;Аббревиатура ЯПВУ расшифровывается так: языки программирования высокого уровня. Сегодня большинство программистов ра
ботают именно на этих языках. Примеры языков высокого уровня:
Паскаль, Бейсик, Си (С), Фортран.</font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;Вот пример записи одной и той же команды сложения двух чисел
на трех языках разного уровня: ЯМК, автокоде и Паскале:</font>

<p><IMG SRC="image/10.png" HEIGHT="150" ALIGN="center">


<p><font size = "4">&nbsp;&nbsp;&nbsp;Видно, как с повышением уровня языка
повышается «понятность» команды (по-английски слово «АП,» означает «сложить»).
Однако чем понятнее язык для человека, тем
он непонятнее для процессора компьютера.
Процессор понимает только ЯМК. Человеку
же легче писать программы на языках более
высокого уровня. Как же быть?</font>

<p><IMG SRC="image/11.png" HEIGHT="300" ALIGN="center">

<p><font size = "4">&nbsp;&nbsp;&nbsp;<b>Трансляция и трансляторы</b>

<p>&nbsp;&nbsp;&nbsp;Как сделать так, чтобы человек мог писать программы на автокоде или Паскале, а компьютер мог исполнять эти программы? Ответ
на поставленный вопрос такой же, как на вопрос «Как мне общаться
с японцем, если я не знаю японского языка?». Нужен переводчик!
По-английски «переводчик» — «translator».</font>

<p><IMG SRC="image/12.png" HEIGHT="200" ALIGN="center">

<p><font size = "4">&nbsp;&nbsp;&nbsp;Таким образом, компьютер сам производит перевод под управле-
нием программы-транслятора. Процесс перевода программы на
язык машинных команд называется трансляцией. Прежде чем вы-
полнить, например, программу на Паскале, ее нужно оттранслиро-
вать. Трансляцию можно представить как спуск с верхней ступень-
ки языка на самую первую ступеньку — ЯМК (рис. 2.18).</font>


<p><IMG SRC="image/13.png" HEIGHT="300" ALIGN="center">

<p><font size = "4">&nbsp;&nbsp;&nbsp;Транслятор является обязательным элементом любой системы
программирования. Первые СП включали в себя только транслятор.
Затем к транслятору стали добавляться различные сервисные сред-
ства: текстовые редакторы, отладчики, системы обслуживания про-
граммных библиотек, средства организации дружественного интер-
фейса с пользователем.</font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;Наиболее удобными для пользователя стали системы программи-
рования, созданные на персональных компьютерах.</font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;Язык программирования, с которым работает СП, называется ее
<i>входным языком.</i> Системы программирования именуются по назва-
нию своего входного языка. Например: «система Бейсик», «система
Паскаль», «система Фортран». Иногда в название систем включают-
ся префиксы, обозначающие, например, ее фирменное происхожде-
ние. Очень популярны системы с приставкой «Турбо»: Турбо Пас-
каль, Турбо С и др. Это системы программирования, разработанные
фирмой Вогland.</font>

<p><font size = "4">&nbsp;&nbsp;&nbsp; <b>О двух способах трансляции</b></font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;Реализовать тот или иной язык программирования на компьюте-
ре — это значит создать транслятор с этого языка для данного ком-
пьютера. Существуют два принципиально различных метода транс-
ляции. Они называются компиляция и интерпретация.</font>

<p><IMG SRC="image/14.png" HEIGHT="300" ALIGN="center">

<p><font size = "4">&nbsp;&nbsp;&nbsp;Для объяснения различия можно предложить такую аналогию:
представьте себе, что иностранный лектор должен выступить перед
аудиторией на незнакомом для слушателей языке. Требуется пере-
вод, который можно организовать двумя способами:</font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;1) полный предварительный перевод: лектор заранее передает
текст выступления переводчику, тот записывает перевод, размно-
жает его и раздает слушателям (после этого лектор может уже и не
выступать);</font>

<p><font size = "4">&nbsp;&nbsp;&nbsp;2) синхронный перевод: лектор читает доклад, переводчик одно-
временно с ним, слово за словом, переводит выступление.</font>


<p><font size = "4">&nbsp;&nbsp;&nbsp;<i>Компиляция является аналогом полного предварительного перевода; интерпретация — аналог синхронного перевода.</i> Транслятор, работающий по принципу компиляции, называется <b>компилятором</b>. Транслятор, работающий методом интерпретации, называется <b>интерпретатором.</b>

<p><font size = "4">&nbsp;&nbsp;&nbsp;<b>Работа компилятора</b>

<p><font size = "4">&nbsp;&nbsp;&nbsp;При компиляции в память компьютера загружается программа-компилятор. Она воспринимает текст программы на ЯПВУ как
исходную информацию. Компилятор производит синтаксический
контроль программы и при обнаружении ошибок выводит диагностические сообщения. Если ошибок нет, то результатом компиляции
является программа на языке машинных команд.

<p><font size = "4">&nbsp;&nbsp;&nbsp;Затем компилятор удаляется из оперативной памяти. В памяти
остается только программа на ЯМК, которая выполняется для получения результатов.

<p><font size = "4">&nbsp;&nbsp;&nbsp;На рисунке 2.19 схематически показан процесс выполнения программы на ЯПВУ с использованием компиляции. Прямоугольниками изображены программы в машинных кодах, овалами — обрабатываемая и конечная информация.


<p><IMG SRC="image/15.png" HEIGHT="300" ALIGN="center">


<p>&nbsp;&nbsp;&nbsp;Конечно, компиляция с автокода (ассемблера) много проще, чем
с языков высокого уровня. Для этой процедуры часто применяют
специальный термин — ассемблирование. А под словом «ассемблер» понимается не только язык программирования, но и транслятор с него.

<p>&nbsp;&nbsp;&nbsp;<b>Работа интерпретатора</b>

<p>&nbsp;&nbsp;&nbsp;Интерпретатор в течение всего времени работы программы находится во внутренней памяти (иногда для этого используется ПЗУ).
В ОЗУ помещается программа на ЯПВУ. Интерпретатор «читает» ее
первый оператор, переводит его в машинные команды и тут же организует выполнение этих команд. Затем переходит к переводу и выполнению следующего оператора, и так до конца программы. При этом результаты предыдущих переводов в памяти не сохраняются.
При повторном выполнении одного и того же оператора в цикле он
снова будет транслироваться. Перед трансляцией каждого оператора происходит его синтаксический анализ.

<p>&nbsp;&nbsp;&nbsp;На рисунке 2.20 схематически показан процесс выполнения программы на ЯПВУ с использованием интерпретатора.

<p><IMG SRC="image/16.png" HEIGHT="300" ALIGN="center">


<p>&nbsp;&nbsp;&nbsp;Таким образом, при компиляции трансляция и исполнение программы идут последовательно друг за другом. При интерпретации —
параллельно.

<p>&nbsp;&nbsp;&nbsp;Один раз откомпилированная программа может быть сохранена
во внешней памяти и затем многократно выполнена. На компиляцию машинное время тратиться больше не будет. Программа на интерпретируемом языке при каждом выполнении подвергается повторной трансляции. Кроме того, интерпретатор может занимать
значительное место в оперативной памяти.

<p>&nbsp;&nbsp;&nbsp;Из-за указанных причин использование компиляторов удобнее
для больших программ, требующих быстрого счета и большого объема памяти. Программы на Паскале, Си, Фортране всегда компилируются. Язык Бейсик часто реализуется через интерпретатор.

<p>&nbsp;&nbsp;&nbsp;<b><u>Коротко о главном</u></b>

 

<p>&nbsp;&nbsp;&nbsp;Для разработки программ программисты используют системы
программирования (СП).

<p>&nbsp;&nbsp;&nbsp;Язык программирования, с которым позволяет работать данная
СП, называется ее входным языком.
Язык процессора компьютера — это язык машинных команд —

ЯМК.

<p>&nbsp;&nbsp;&nbsp;Уровень языка программирования определяется степенью его
удаленности от ЯМК (чем дальше, тем выше уровень).


<p>&nbsp;&nbsp;&nbsp;Автокод (ассемблер) — это машинно-ориентированный язык символического программирования.

<p>&nbsp;&nbsp;&nbsp;Наиболее удобным средством программирования являются языки высокого уровня (ЯПВУ). Сегодня с ними работает большинство
программистов.

<p>&nbsp;&nbsp;&nbsp;Трансляция — это процесс перевода текста программы на язык
машинных команд. Программа-переводчик называется транслятором.

<p>&nbsp;&nbsp;&nbsp;Существуют два способа трансляции: компиляция и интерпретация.
При компиляции сначала весь текст программы переводится на ЯМК,
затем производится ее исполнение. При интерпретации перевод и исполнение происходят параллельно.

<p><b><u>Вопросы и задания</u></b>
<p>&nbsp;&nbsp;&nbsp;1. Что такое язык программирования?
<p>&nbsp;&nbsp;&nbsp;2. Что обозначает понятие «уровень языка программирования» ?
<p>&nbsp;&nbsp;&nbsp;3. К какому уровню относятся языки типа автокод (ассемблер)?

<p>&nbsp;&nbsp;&nbsp;4. Почему языки программирования высокого уровня называют машинно-независимыми языками?

<p>&nbsp;&nbsp;&nbsp;5. Какие из языков программирования высокого уровня вы знаете?
<p>&nbsp;&nbsp;&nbsp;6. Что такое трансляция? Что такое транслятор?
<p>&nbsp;&nbsp;&nbsp;7. В чем различие между компиляцией и интерпретацией?
</p>

<A NAME="2.4">
<h1 align ="center">
<b>2.4.История языков программирования</b>
</h1>

<P ALIGN="left">
<p><font size = "4"><I><b>Основные темы параграфа:</b></I></font>

<p><font size = "4">&nbsp;&nbsp;<I>*первые шаги автоматизации программироания;</I></font>
<p><font size = "4">&nbsp;&nbsp;<I>*первые языки высокого уровня:Кобол и Фортран;</I></font>

<p><font size = "4">&nbsp;&nbsp;<I>*языки процедурного программирования;</I></font>
<p><font size = "4">&nbsp;&nbsp;<I>*Языки искусственного интеллекта.</I></font>
<p><font size = "4">&nbsp;&nbsp;<I>*современные языки объектно-ориентированного и визуального программирования;</I></font>
<p><font size = "4">&nbsp;&nbsp;<I>*программны продукт и его жизненны цикл.</I></font>

<p><b>&nbsp;&nbsp;&nbsp;Первые шаги автоматизации программирования</b>

<p>&nbsp;&nbsp;&nbsp;Программы для первых ЭВМ программисты писали на языках машинных команд. Это очень трудоемкий и длительный процесс. Проходило значительное время между началом составления программы
и началом ее использования. Решить эту проблему можно было
лишь путем создания средств автоматизации программирования.
 
 <h1>Тест по параграфу 2.1</h1>

<section class="main">

<form name="quiz" action="javascript:check();" class="quizform">

<div class="quizsection">


	<h2>Как называется длинный целый тип?</h2>
	
	<div class="answer">
		<input name="q1" value="value2" id="value1" type="radio" checked="checked" /> longint
	</div>

	<div class="answer">
		<input name="q1" value="value1" id="value2" type="radio" /> int
	</div>

	<div class="answer">
		<input name="q1" value="value1" id="value3" type="radio" /> string
	</div>

</div>

<div class="quizsection">

	<h2>для чего нужна операция div?</h2>

	<div class="answer">
		<input name="q2" value="value1" id="value1" type="radio" checked="checked" /> Умножение
	</div>

	<div class="answer">
		<input name="q2" value="value2" id="value2" type="radio" /> Деление без остатка  
	</div>

	<div class="answer">
		<input name="q2" value="value1" id="value3" type="radio" /> Деление с остатком
	</div>

	<div class="answer">
		<input name="q2" value="value1" id="value4" type="radio" /> Вычитание
	</div>

	<div class="answer">
		<input name="q2" value="value1" id="value5" type="radio" /> Сложение
	</div>


</div>

<h1>Тест по параграфу 2.2</h1>

<section class="main">

<form name="quiz" action="javascript:check();" class="quizform">

<div class="quizsection">


	<h2>С чем связана объемная сложность?</h2>
	
	<div class="answer">
		<input name="q1" value="value1" id="value1" type="radio" checked="checked" /> С временем обработки
	</div>

	<div class="answer">
		<input name="q1" value="value1" id="value2" type="radio" /> С количеством операций
	</div>

	<div class="answer">
		<input name="q1" value="value2" id="value3" type="radio" /> С количеством данных
	</div>

</div>

<div class="quizsection">

	<h2>С чем связана временная сложность?</h2>

	<div class="answer">
		<input name="q2" value="value1" id="value1" type="radio" checked="checked" /> С объемом данный
	</div>

	<div class="answer">
		<input name="q2" value="value2" id="value2" type="radio" /> С количеством операций
	</div>

	<div class="answer">
		<input name="q2" value="value1" id="value3" type="radio" /> С временем обработки
	</div>



</div>

<div class="quizsection">

	<h2>Какой проект является примером решения фундаментальной математической проблемы методм поиска?</h2>

	<div class="answer">
		<input name="q2" value="value2" id="value1" type="radio" checked="checked" /> GIMPS
	</div>

	<div class="answer">
		<input name="q2" value="value1" id="value2" type="radio" /> Pascal
	</div>

	<div class="answer">
		<input name="q2" value="value1" id="value3" type="radio" /> Google
	</div>



</div>
<div class="quizsection">

	<h2>Какой критерий слжности используется в программировнии</h2>

	<div class="answer">
		<input name="q2" value="value1" id="value1" type="radio" checked="checked" /> Большая сложность 
	</div>

	<div class="answer">
		<input name="q2" value="value2" id="value2" type="radio" /> Временная сложность 
	</div>

	<div class="answer">
		<input name="q2" value="value1" id="value3" type="radio" /> Средняя сложность
	</div>



</div>



<h1>Тест по параграфу 2.3</h1>

<section class="main">

<form name="quiz" action="javascript:check();" class="quizform">

<div class="quizsection">


	<h2>Какой родной язык ЭВМ?</h2>
	
	<div class="answer">
		<input name="q1" value="value2" id="value1" type="radio" checked="checked" /> ЯМК
	</div>

	<div class="answer">
		<input name="q1" value="value1" id="value2" type="radio" /> Pascal
	</div>

	<div class="answer">
		<input name="q1" value="value1" id="value3" type="radio" /> BIOS
	</div>

</div>

<div class="quizsection">

	<h2>Как называются программы-переводчики с автокода?</h2>

	<div class="answer">
		<input name="q2" value="value1" id="value1" type="radio" checked="checked" /> Транслитор 
	</div>

	<div class="answer">
		<input name="q2" value="value2" id="value2" type="radio" /> Транслятор
	</div>

	<div class="answer">
		<input name="q2" value="value1" id="value3" type="radio" /> Обработчик
	</div>



</div>
<div class="quizsection">

	<h2>Как называется один из способов перевода?</h2>

	<div class="answer">
		<input name="q2" value="value1" id="value1" type="radio" checked="checked" /> Несинхронный перевод 
	</div>

	<div class="answer">
		<input name="q2" value="value2" id="value2" type="radio" /> Синхронный перевод
	</div>

	<div class="answer">
		<input name="q2" value="value1" id="value3" type="radio" /> Сложный перевод
	</div>



</div>
<input value="Submit" type="submit" /> <input value="Reset" type="reset" />

</form>

</section>

<script type="text/javascript">// <![CDATA[

   var result;
   
   function check()

   {

      var question;
      var value1;
      var value2;
      
      
      question = 1;
      value1 = 0;
      value2 = 0;
      
      
      result = "";

      var choice;
      
      for (question = 1; question <= 7; question++) {
      
         var q = document.forms['quiz'].elements['q'+question];

            for (var i = 0; i < q.length; i++) {
               if (q[i].checked) {
                  choice = q[i].value;
               }
            }

            if (choice == "value1") {
               value1++;
            }

            if (choice == "value2") {
               value2++;
            }


         }

      if (value2 == 0) {

         // Нет правильных ответов
         result = "ocenka2";

      }
	else if (value2 == 1) {

         // Один правильный ответ
         result = "ocenka2";

      }
	else if (value2 == 2) {

         // Один правильный ответ
         result = "ocenka2";

      }
	else if (value2 == 3) {

         // Один правильный ответ
         result = "ocenka2";

      }
      else if (value2 == 4) {

         // Один правильный ответ
         result = "ocenka3";

      }
	else if (value2 == 5) {

         // Один правильный ответ
         result = "ocenka3";

      }

      else if (value2 == 6) {

         // Два правильных ответа
         result = "ocenka4";

      }

      else if (value2 == 7) {

         // Три правильных ответа
         result = "ocenka5";

      }


      else {
         result = "404";
      }

      window.location = result + '.html';

   }

// ]]></script>

</HTML>
